---
title: "Idempotence et debounce dans BullMQ : durcir les jobs avec un contrat jobify"
subtitle: "reschedule vs time-frame, job IDs deterministes, et modes de panne cote workers."
summary: "Mise en place d'une execution idempotente et debouncee des jobs BullMQ avec identifiants deterministes."
publishedAt: "2023-09-01"
readTimeMinutes: 13
tags:
  - bullmq
  - idempotence
  - workers
  - architecture
seriesId: "async-workloads-at-scale"
seriesOrder: 3
---

Après avoir réussi à empêcher nos exports stream de faire fondre les serveurs, le boss final suivant n'était pas le débit, mais le bruit absolu dans les queues : des triggers répétés frénétiquement pour la même entité, des doublons de jobs venus de nulle part, et des retrys chaotiques en cas de pic de charge.

C'est exactement là que l'idempotence et le debounce devaient cesser d'être des options "sympas à avoir". BullMQ est resté en place, mais nous lui avons imposé un contrat `jobify` strict et autoritaire pour encadrer la création et l'exécution des jobs.

**Serie: Async Workloads at Scale (Partie 3/3)**

Ce post clot une serie en 3 parties :

- Partie 1 - [backpressure Node.js, streaming et exports multipart](../nodejs-stream-backpressure-history-export/fr.mdx)
- Partie 2 - [Jobify + BullMQ + workers + queues dans une architecture NestJS](../jobify-workers-queues-nestjs/fr.mdx)
- Partie 3 (courante) - conception idempotence et debounce.

**Idempotence: execution sure meme avec triggers multiples. Debounce: choisir quand executer sous tempete d'evenements.**

## Point de départ NestJS, puis durcissement (Car les tutos de base sont un piège)

Le pattern classique NestJS via `@InjectQueue` est rapide a mettre en place, mais fragile quand le nombre de jobs augmente.

```typescript
await queue.add(
  "sync-agent",
  { environmentId },
  {
    priority: 2,
    removeOnComplete: true,
    removeOnFail: true,
  },
);
```

## Ce que make-jobify.ts impose

- debounce impose `delayInMs`, `makeJobId` et `name`.
- registration des processors uniquement sur les instances worker.
- un seul chemin d'enqueue et de monitoring pour tous les jobs.

## Deux modes debounce, deux comportements

### 1) time-frame

Utilise notamment dans `action-approvers-notifier-service.ts` et `self-hosted-agent-config-change-service.ts`. Les triggers frequents sur la meme cle sont regroupes dans une fenetre de temps fixe.

### 2) reschedule

Utilise dans `cloud-synchronize-data-service.ts`. Si un job delayed existe deja, on prolonge son delai via `changeDelay` au lieu d'ajouter un nouveau job.

## Nuance critique: fraicheur du payload

Les deux modes peuvent conserver le payload initial quand un job existe deja pour la meme cle. Si les nouveaux triggers portent des arguments differents, vous pouvez executer des donnees obsoletes.

**Regle: inclure tous les arguments qui changent le comportement dans makeJobId, ou relire l'etat le plus recent dans le processor.**

## Patterns d'idempotence robustes

- schema de cle deterministe `<job-name>:<tenant>:<entity>:<time-range>:<mode>`;
- eviter timestamps aleatoires et UUIDs dans makeJobId;
- trier/canonicaliser les listes avant composition de cle;
- toujours inclure le scope tenant/environment.

## Modes de panne (Et comment éviter de réveiller l'équipe d'astreinte)

| Mode de panne                   | Cause                                    | Garde-fou                                          |
| :------------------------------ | :--------------------------------------- | :------------------------------------------------- |
| Doublons de jobs couteux        | jobId absent ou instable                 | makeJobId deterministe + tests de contrat          |
| Payload obsoletes               | job debounce avec anciennes donnees      | cle plus fine ou lecture d'etat recente au runtime |
| Croissance silencieuse de queue | absence de removeOnComplete/removeOnFail | centraliser addJob dans QueueService               |
| Shutdown worker bloque          | pas de policy de timeout                 | wrapper worker avec timeout par defaut             |

## Ou placer make-jobify-sequential

Ce n'est pas du debounce. C'est de l'ordre strict par entite quand la concurrence est interdite pour la meme lane logique.

## Guide de choix

- **time-frame:** une execution par fenetre en cas de burst.
- **reschedule:** execution apres une periode de calme.

Le resultat attendu est un runtime asynchrone plus deterministe: moins de doublons, pression queue bornee, et workers stables sous charge.

## Navigation dans la serie

- Besoin de fiabilite stream en premier ? Lire [Partie 1](../nodejs-stream-backpressure-history-export/fr.mdx).
- Besoin du contrat queue/worker ensuite ? Lire [Partie 2](../jobify-workers-queues-nestjs/fr.mdx).

_Note : Cet article a été écrit a posteriori, après mon départ de Forest Admin._
