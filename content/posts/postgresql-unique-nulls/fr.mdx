---
title: "Petit retour d'expérience : ON CONFLICT DO UPDATE avec des colonnes nullable"
subtitle: "Attention : Par défaut, PostgreSQL considère que NULL ≠ NULL."
summary: "Comment utiliser NULLS NOT DISTINCT pour que ON CONFLICT et les index uniques se comportent comme prévu avec des colonnes nullables."
publishedAt: "2026-01-26"
readTimeMinutes: 2
tags:
  - postgresql
  - database
  - backend
---

Je viens de brûler une honteuse heure de ma précieuse existence sur un cas "impossible". Mon `ON CONFLICT DO UPDATE` passait royalement à côté de doublons évidents alors que j'avais bétonné ma table avec une contrainte d'unicité.

## Le Dénouement

Le piège est là : par défaut, la philosophie de PostgreSQL c'est que `NULL ≠ NULL`. C'est à dire que si vous lui présentez deux lignes `(valeur, NULL)`, il va vous soutenir mordicus que ce n'est pas la même chose. Exit la notion de doublons !

## La Formule Magique

Pour éviter de vous arracher les cheveux, il suffit d'ajouter l'incantation magique `NULLS NOT DISTINCT` à l'index unique :

```sql
CREATE UNIQUE INDEX idx_product_unique
ON products (isin, provider_product_reference)
NULLS NOT DISTINCT;
```

Et hop, PostgreSQL accepte enfin qu'un vide ait la même saveur qu'un autre vide lors de la vérification d'unicité. Résultat : vos upserts re-fonctionnent de nouveau comme par magie.

_Pro tip : ce petit sauveur de vie est dispo depuis PostgreSQL 15. Jetez un œil aux docs : [Unique Nulls Not Distinct](https://www.postgresql.org/about/featurematrix/detail/unique-nulls-not-distinct/)._
